import java.util.Comparator;
import java.util.List;

public class Collections {

    /**
     * Выполняет двоичный поиск в указанном списке по указанному ключу, используя естественное упорядочивание его элементов.
     * Перед вызовом этого метода список должен быть отсортирован в порядке возрастания в соответствии с естественным упорядочиванием.
     * Если список не отсортирован, результат не определён.
     *
     * @param <T>  тип элементов в списке, которые должны реализовывать {@code Comparable}
     * @param list список для поиска
     * @param key  значение, которое нужно найти
     * @return индекс ключа поиска, если он содержится в списке; в противном случае — (точка вставки) — 1.
     * Точка вставки определяется как точка, в которую ключ будет вставлен в список:
     * индекс первого элемента, превышающего ключ, или {@code list.size()},
     * если все элементы в списке меньше указанного ключа.
     */
    public static <T extends Comparable<? super T>> int binarySearch(List<T> list, T key) {
        return binarySearch(list, key, Comparator.naturalOrder());
    }

    /**
     * Выполняет двоичный поиск в указанном списке по указанному ключу с помощью заданного компаратора.
     * Перед вызовом этого метода список должен быть отсортирован в соответствии с заданным компаратором.
     * Если список не отсортирован, результат не определён.
     *
     * @param <T>  тип элементов в списке
     * @param list список для поиска
     * @param key  значение, которое нужно найти
     * @param c    компаратор, используемый для определения порядка в списке; значение null недопустимо
     * @return индекс ключа поиска, если он содержится в списке; в противном случае — (точка вставки) — 1.
     * Точка вставки определяется как точка, в которую ключ будет вставлен в список: индекс первого элемента, превышающего
     * ключ, или {@code list.size()}, если все элементы в списке меньше указанного ключа.
     */
    public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c) {
        int low = 0;
        int high = list.size() - 1;

        while (low <= high) {
            int mid = (low + high) >>> 1;
            T midVal = list.get(mid);
            int cmp = c.compare(midVal, key);

            if (cmp < 0) {
                low = mid + 1;
            } else if (cmp > 0) {
                high = mid - 1;
            } else {
                return mid;
            }
        }
        return -(low + 1);
    }

}
